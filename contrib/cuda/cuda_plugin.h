// Generated by cuda-wrappers.py and main.template
#ifndef _CUDA_PLUGIN_H_
#define _CUDA_PLUGIN_H_

// FIXME: Some of these #includes are not needed

#include <unistd.h>
#include <stdint.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <cuda_runtime_api.h>

#include "cuda_plugin.h"
#include "jassert.h"
#include "dmtcp_dlsym.h"
#include "dmtcp.h"

#define DEBUG_SIGNATURE "[CUDA Plugin]"
#ifdef CUDA_PLUGIN_DEBUG
# define DPRINTF(fmt, ...) \
  do { fprintf(stderr, DEBUG_SIGNATURE fmt, ## __VA_ARGS__); } while (0)
#else // ifdef CUDA_PLUGIN_DEBUG
# define DPRINTF(fmt, ...) \
  do {} while (0)
#endif // ifdef CUDA_PLUGIN_DEBUG


#define   _real_fork      NEXT_FNC_DEFAULT(fork)

#define   _real_cudaMalloc      NEXT_FNC_DEFAULT(cudaMalloc)
#define   _real_cudaMemcpy      NEXT_FNC_DEFAULT(cudaMemcpy)
#define   _real_dlopen          NEXT_FNC_DEFAULT(dlopen)
#define   _real_dlclose         NEXT_FNC_DEFAULT(dlclose)
#define   _real_dlsym           NEXT_FNC_DEFAULT(dlsym)
#define   _real_cuLaunchKernel  NEXT_FNC_DEFAULT(cuLaunchKernel)

#define   _real_cudaConfigureCall     NEXT_FNC_DEFAULT(cudaConfigureCall)
#define   _real_cudaLaunch            NEXT_FNC_DEFAULT(cudaLaunch)
#define   _real_cudaFuncGetAttributes NEXT_FNC_DEFAULT(cudaFuncGetAttributes)
#define   _real_cudaSetupArgument     NEXT_FNC_DEFAULT(cudaSetupArgument)
#define   _real_cudaLaunchKernel      NEXT_FNC_DEFAULT(cudaLaunchKernel)

#define True    1
#define False   0

#define SKTNAME "proxy"
#define LOGFILE "cudaSysCallsLog"

#define SHMSIZE 128

extern int initialized;
extern int ufd_initialized;
extern int segvfault_initialized;
extern void *shmaddr;
extern int logFd;
extern int page_size;

extern bool haveDirtyPages;

extern int skt_master;
// proxy address
extern struct sockaddr_un sa_proxy;

extern bool enableCudaCallLogging;


// #define PYTHON_AUTO_GENERATE 1
void proxy_initialize();

static inline void*
getAlignedAddress(uintptr_t ptr, size_t alignment)
{
  const size_t mask = alignment - 1;
  return (void *) (ptr & ~mask);
}

void proxy_initialize(void);
void copy_data_to_host(void);
void copy_data_to_device(void);

void log_append(void *ptr, size_t size);
void * log_read(size_t *size);

void disable_cuda_call_logging();
void enable_cuda_call_logging();
bool should_log_cuda_calls();

void userfaultfd_initialize(void);
void segvfault_initialize(void);
void reset_uffd(void);
void* create_shadow_pages(size_t size, void *remoteAddress = NULL);
void unregister_all_pages();
void register_all_pages();
void flushDirtyPages();

// This is now static, scope within one file
// dmtcp::map<void*, void*>& shadowPageMap()fdef PYTHON_AUTO_GENERATE
//  askdaj aslkdas;
//  #endif
//  ;


enum cuda_op {
  OP_cudaMalloc,
  OP_cudaFree,
  OP_cudaPointerGetAttributes,
  OP_cudaMemcpy,
  OP_cudaMemcpy2D,
  OP_cudaMallocArray,
  OP_cudaFreeArray,
  OP_cudaConfigureCall,
  OP_cudaSetupArgument,
  OP_cudaLaunch,
  OP_cudaThreadSynchronize,
  OP_cudaGetLastError,
  OP_cudaMallocPitch,
  OP_cudaDeviceReset,
  OP_cudaCreateTextureObject,
  OP_cudaPeekAtLastError,
  OP_cudaProfilerStart,
  OP_cudaProfilerStop,
  OP_cudaStreamSynchronize,
  OP_cudaUnbindTexture,
  OP_cudaDestroyTextureObject,
  OP_cudaEventQuery,
  OP_cudaDeviceCanAccessPeer,
  OP_cudaDeviceGetAttribute,
  OP_cudaDeviceSetCacheConfig,
  OP_cudaDeviceSetSharedMemConfig,
  OP_cudaDeviceSynchronize,
  OP_cudaEventCreateWithFlags,
  OP_cudaEventCreate,
  OP_cudaEventDestroy,
  OP_cudaEventSynchronize,
  OP_cudaEventElapsedTime,
  OP_cudaEventRecord,
  OP_cudaFuncGetAttributes,
  OP_cudaGetDevice,
  OP_cudaGetDeviceCount,
  OP_cudaGetDeviceProperties,
  OP_cudaMemset,
  OP_cudaSetDevice,
  OP_cudaMemcpyAsync,
  OP_cudaMemsetAsync,
  OP_cudaOccupancyMaxActiveBlocksPerMultiprocessor,
  OP_cudaCreateChannelDesc,
  OP_cudaFuncSetCacheConfig,
  OP_cudaGetErrorString,
  OP_cudaMemGetInfo,
  OP_cudaMemcpyToArray,
  OP_cudaStreamCreate,
  OP_cudaThreadExit,
  OP_cudaMallocManaged,
  OP_LAST_FNC
};

void FNC_cudaMalloc(void);
void FNC_cudaFree(void);
void FNC_cudaPointerGetAttributes(void);
void FNC_cudaMemcpy(void);
void FNC_cudaMemcpy2D(void);
void FNC_cudaMallocArray(void);
void FNC_cudaFreeArray(void);
void FNC_cudaConfigureCall(void);
void FNC_cudaSetupArgument(void);
void FNC_cudaLaunch(void);
void FNC_cudaThreadSynchronize(void);
void FNC_cudaGetLastError(void);
void FNC_cudaMallocPitch(void);
void FNC_cudaDeviceReset(void);
void FNC_cudaCreateTextureObject(void);
void FNC_cudaPeekAtLastError(void);
void FNC_cudaProfilerStart(void);
void FNC_cudaProfilerStop(void);
void FNC_cudaStreamSynchronize(void);
void FNC_cudaUnbindTexture(void);
void FNC_cudaDestroyTextureObject(void);
void FNC_cudaEventQuery(void);
void FNC_cudaDeviceCanAccessPeer(void);
void FNC_cudaDeviceGetAttribute(void);
void FNC_cudaDeviceSetCacheConfig(void);
void FNC_cudaDeviceSetSharedMemConfig(void);
void FNC_cudaDeviceSynchronize(void);
void FNC_cudaEventCreateWithFlags(void);
void FNC_cudaEventCreate(void);
void FNC_cudaEventDestroy(void);
void FNC_cudaEventSynchronize(void);
void FNC_cudaEventElapsedTime(void);
void FNC_cudaEventRecord(void);
void FNC_cudaFuncGetAttributes(void);
void FNC_cudaGetDevice(void);
void FNC_cudaGetDeviceCount(void);
void FNC_cudaGetDeviceProperties(void);
void FNC_cudaMemset(void);
void FNC_cudaSetDevice(void);
void FNC_cudaMemcpyAsync(void);
void FNC_cudaMemsetAsync(void);
void FNC_cudaOccupancyMaxActiveBlocksPerMultiprocessor(void);
void FNC_cudaCreateChannelDesc(void);
void FNC_cudaFuncSetCacheConfig(void);
void FNC_cudaGetErrorString(void);
void FNC_cudaMemGetInfo(void);
void FNC_cudaMemcpyToArray(void);
void FNC_cudaStreamCreate(void);
void FNC_cudaThreadExit(void);
void FNC_cudaMallocManaged(void);

#endif // ifndef _CUDA_PLUGIN_H_
