#include <stdio.h>
#include <string.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <cuda_runtime_api.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <limits.h>

#include "config.h"
#include "cuda_plugin.h"

struct MallocRegion {
  void *addr;
  void *host_addr;
  size_t len;
};

static dmtcp::vector<MallocRegion>&
allMallocRegions()
{
  static dmtcp::vector<MallocRegion> *instance = NULL;
  if (instance == NULL) {
    void *buffer = JALLOC_MALLOC(1024 * 1024);
    instance = new (buffer)dmtcp::vector<MallocRegion>();
  }
  return *instance;
}

void
copy_data_to_host()
{
  dmtcp::vector<MallocRegion>::iterator it;
  for (it = allMallocRegions().begin(); it != allMallocRegions().end(); it++) {
    void *page = mmap(NULL, it->len, PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    JASSERT(page != MAP_FAILED)(JASSERT_ERRNO);
    it->host_addr = page;
    cudaMemcpy(page, it->addr, it->len, cudaMemcpyDeviceToHost);
  }
}

void
copy_data_to_device()
{
  dmtcp::vector<MallocRegion>::iterator it;
  for (it = allMallocRegions().begin(); it != allMallocRegions().end(); it++) {
    cudaMemcpy(it->addr, it->host_addr, it->len, cudaMemcpyHostToDevice);
  }
}

//================================================================


// Generated by cuda-wrappers.py and main.template

EXTERNC enum cudaMemcpyKind
cudaMemcpyGetDirection(const void *destPtr, const void *srcPtr,
                       enum cudaMemcpyKind *direction);

EXTERNC cudaError_t
cudaMalloc(void * * pointer, size_t size)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMalloc;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & size, sizeof size);
  chars_sent += sizeof size;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *pointer;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(pointer, recv_buf + chars_rcvd, sizeof *pointer);
  chars_rcvd += sizeof *pointer;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);
  return ret_val;
}

EXTERNC cudaError_t
cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaPointerGetAttributes;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & ptr, sizeof ptr);
  chars_sent += sizeof ptr;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *attributes;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(attributes, recv_buf + chars_rcvd, sizeof *attributes);
  chars_rcvd += sizeof *attributes;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaMemcpy(void * dst, const void * src, size_t count, enum cudaMemcpyKind kind)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemcpy;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & count, sizeof count);
  chars_sent += sizeof count;
  memcpy(send_buf + chars_sent, & kind, sizeof kind);
  chars_sent += sizeof kind;
  memcpy(send_buf + chars_sent, &dst, sizeof dst);
  chars_sent += sizeof dst;
  memcpy(send_buf + chars_sent, &src, sizeof src);
  chars_sent += sizeof src;
  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  enum cudaMemcpyKind direction;
  if (kind == cudaMemcpyDefault) {
    cudaMemcpyGetDirection(dst, src, &direction);
  }
  int size = -1;
  size = count;
  direction = kind;
  if (direction == cudaMemcpyHostToHost) {
    memcpy(dst, src, size);
  }
  else if (direction == cudaMemcpyHostToDevice) {
    JASSERT(write(skt_master, src, size) == size) (JASSERT_ERRNO);
  }
  else if (direction == cudaMemcpyDeviceToHost) {
    JASSERT(read(skt_master, dst, size) == size)
           (JASSERT_ERRNO);
  }
  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.
  size = sizeof ret_val;
  JASSERT(read(skt_master, &ret_val, size) == size)
         (JASSERT_ERRNO);

  return ret_val;
}

EXTERNC cudaError_t
cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch,
            size_t width, size_t height, enum cudaMemcpyKind kind)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemcpy2D;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & dpitch, sizeof dpitch);
  chars_sent += sizeof dpitch;
  memcpy(send_buf + chars_sent, & spitch, sizeof spitch);
  chars_sent += sizeof spitch;
  memcpy(send_buf + chars_sent, & width, sizeof width);
  chars_sent += sizeof width;
  memcpy(send_buf + chars_sent, & height, sizeof height);
  chars_sent += sizeof height;
  memcpy(send_buf + chars_sent, & kind, sizeof kind);
  chars_sent += sizeof kind;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  enum cudaMemcpyKind direction;
  if (kind == cudaMemcpyDefault) {
    cudaMemcpyGetDirection(dst, src, &direction);
  }
  int size = -1;
  size = spitch * height;
  direction = kind;
  if (direction == cudaMemcpyHostToDevice ||
      direction == cudaMemcpyHostToHost) {
    // Send source buffer to proxy process
    // NOTE: As an optimization, HostToHost could be done locally.
    // NOTE:  This assumes no pinnned memory.
    JASSERT(write(skt_master, src, size) == size) (JASSERT_ERRNO);
  }
  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);
  size = dpitch * height;
  direction = kind;
  if (direction == cudaMemcpyDeviceToHost ||
      direction == cudaMemcpyHostToHost) {
    // Receive dest buffer from proxy process
    // NOTE:  This assumes no pinnned memory.
    JASSERT(read(skt_master, dst, size) == size) (JASSERT_ERRNO);
  }

  return ret_val;
}

EXTERNC cudaError_t
cudaMallocArray(struct cudaArray * * array,
const struct cudaChannelFormatDesc * desc,
size_t width, size_t height, unsigned int flags)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMallocArray;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, desc, sizeof *desc);
  chars_sent += sizeof *desc;
  memcpy(send_buf + chars_sent, & width, sizeof width);
  chars_sent += sizeof width;
  memcpy(send_buf + chars_sent, & height, sizeof height);
  chars_sent += sizeof height;
  memcpy(send_buf + chars_sent, & flags, sizeof flags);
  chars_sent += sizeof flags;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *array;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(array, recv_buf + chars_rcvd, sizeof *array);
  chars_rcvd += sizeof *array;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaFreeArray(struct cudaArray * array)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaFreeArray;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & array, sizeof array);
  chars_sent += sizeof array;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaConfigureCall(dim3 gridDim, dim3 blockDim,
         size_t sharedMem, cudaStream_t stream)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaConfigureCall;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & gridDim, sizeof gridDim);
  chars_sent += sizeof gridDim;
  memcpy(send_buf + chars_sent, & blockDim, sizeof blockDim);
  chars_sent += sizeof blockDim;
  memcpy(send_buf + chars_sent, & sharedMem, sizeof sharedMem);
  chars_sent += sizeof sharedMem;
  memcpy(send_buf + chars_sent, & stream, sizeof stream);
  chars_sent += sizeof stream;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.
  chars_rcvd = sizeof ret_val;
  JASSERT(read(skt_master, &ret_val, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);
  return ret_val;
}

EXTERNC cudaError_t
cudaSetupArgument(const void * arg, size_t size, size_t offset)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaSetupArgument;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & arg, sizeof arg);
  chars_sent += sizeof arg;
  memcpy(send_buf + chars_sent, & size, sizeof size);
  chars_sent += sizeof size;
  memcpy(send_buf + chars_sent, & offset, sizeof offset);
  chars_sent += sizeof offset;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.
  chars_rcvd = sizeof ret_val;
  JASSERT(read(skt_master, &ret_val, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);
  return ret_val;
}

EXTERNC cudaError_t
cudaLaunch(const void * func)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaLaunch;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, &func, sizeof func);
  chars_sent += sizeof func;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.
  chars_rcvd = sizeof ret_val;
  JASSERT(read(skt_master, &ret_val, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  return ret_val;
}

EXTERNC cudaError_t
cudaThreadSynchronize()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaThreadSynchronize;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaGetLastError()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaGetLastError;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaMallocPitch(void * * devPtr, size_t * pitch, size_t width, size_t height)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMallocPitch;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & width, sizeof width);
  chars_sent += sizeof width;
  memcpy(send_buf + chars_sent, & height, sizeof height);
  chars_sent += sizeof height;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *devPtr + sizeof *pitch;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(devPtr, recv_buf + chars_rcvd, sizeof *devPtr);
  chars_rcvd += sizeof *devPtr;
  memcpy(pitch, recv_buf + chars_rcvd, sizeof *pitch);
  chars_rcvd += sizeof *pitch;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDeviceReset()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDeviceReset;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  log_append(send_buf, chars_sent);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaCreateTextureObject(cudaTextureObject_t * pTexObject,
                const struct cudaResourceDesc * pResDesc,
                const struct cudaTextureDesc * pTexDesc,
        const struct cudaResourceViewDesc * pResViewDesc)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaCreateTextureObject;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & pResDesc, sizeof pResDesc);
  chars_sent += sizeof pResDesc;
  memcpy(send_buf + chars_sent, & pTexDesc, sizeof pTexDesc);
  chars_sent += sizeof pTexDesc;
  memcpy(send_buf + chars_sent, & pResViewDesc, sizeof pResViewDesc);
  chars_sent += sizeof pResViewDesc;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *pTexObject;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(pTexObject, recv_buf + chars_rcvd, sizeof *pTexObject);
  chars_rcvd += sizeof *pTexObject;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaPeekAtLastError()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaPeekAtLastError;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaProfilerStart()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaProfilerStart;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaProfilerStop()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaProfilerStop;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaStreamSynchronize(cudaStream_t stream)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaStreamSynchronize;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & stream, sizeof stream);
  chars_sent += sizeof stream;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaUnbindTexture(const textureReference * texref)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaUnbindTexture;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & texref, sizeof texref);
  chars_sent += sizeof texref;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDestroyTextureObject(cudaTextureObject_t texObject)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDestroyTextureObject;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & texObject, sizeof texObject);
  chars_sent += sizeof texObject;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventQuery(cudaEvent_t event)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventQuery;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & event, sizeof event);
  chars_sent += sizeof event;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDeviceCanAccessPeer;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & device, sizeof device);
  chars_sent += sizeof device;
  memcpy(send_buf + chars_sent, & peerDevice, sizeof peerDevice);
  chars_sent += sizeof peerDevice;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *canAccessPeer;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(canAccessPeer, recv_buf + chars_rcvd, sizeof *canAccessPeer);
  chars_rcvd += sizeof *canAccessPeer;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDeviceGetAttribute;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & attr, sizeof attr);
  chars_sent += sizeof attr;
  memcpy(send_buf + chars_sent, & device, sizeof device);
  chars_sent += sizeof device;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *value;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(value, recv_buf + chars_rcvd, sizeof *value);
  chars_rcvd += sizeof *value;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDeviceSetCacheConfig;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & cacheConfig, sizeof cacheConfig);
  chars_sent += sizeof cacheConfig;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDeviceSetSharedMemConfig;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & config, sizeof config);
  chars_sent += sizeof config;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaDeviceSynchronize()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaDeviceSynchronize;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventCreateWithFlags(cudaEvent_t * event, unsigned int flags)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventCreateWithFlags;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & flags, sizeof flags);
  chars_sent += sizeof flags;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *event;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(event, recv_buf + chars_rcvd, sizeof *event);
  chars_rcvd += sizeof *event;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventCreate(cudaEvent_t * event)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventCreate;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *event;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(event, recv_buf + chars_rcvd, sizeof *event);
  chars_rcvd += sizeof *event;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventDestroy(cudaEvent_t event)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventDestroy;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & event, sizeof event);
  chars_sent += sizeof event;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventSynchronize(cudaEvent_t event)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventSynchronize;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & event, sizeof event);
  chars_sent += sizeof event;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventElapsedTime;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & start, sizeof start);
  chars_sent += sizeof start;
  memcpy(send_buf + chars_sent, & end, sizeof end);
  chars_sent += sizeof end;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *ms;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(ms, recv_buf + chars_rcvd, sizeof *ms);
  chars_rcvd += sizeof *ms;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaEventRecord(cudaEvent_t event, cudaStream_t stream)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaEventRecord;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & event, sizeof event);
  chars_sent += sizeof event;
  memcpy(send_buf + chars_sent, & stream, sizeof stream);
  chars_sent += sizeof stream;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaFuncGetAttributes;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & func, sizeof func);
  chars_sent += sizeof func;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *attr;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(attr, recv_buf + chars_rcvd, sizeof *attr);
  chars_rcvd += sizeof *attr;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaGetDevice(int * device)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaGetDevice;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *device;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(device, recv_buf + chars_rcvd, sizeof *device);
  chars_rcvd += sizeof *device;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaGetDeviceCount(int * count)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaGetDeviceCount;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *count;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(count, recv_buf + chars_rcvd, sizeof *count);
  chars_rcvd += sizeof *count;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaGetDeviceProperties(cudaDeviceProp * prop, int device)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaGetDeviceProperties;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, prop, sizeof *prop);
  chars_sent += sizeof *prop;
  memcpy(send_buf + chars_sent, & device, sizeof device);
  chars_sent += sizeof device;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *prop;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(prop, recv_buf + chars_rcvd, sizeof *prop);
  chars_rcvd += sizeof *prop;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaMemset(void * devPtr, int value, size_t count)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemset;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & devPtr, sizeof devPtr);
  chars_sent += sizeof devPtr;
  memcpy(send_buf + chars_sent, & value, sizeof value);
  chars_sent += sizeof value;
  memcpy(send_buf + chars_sent, & count, sizeof count);
  chars_sent += sizeof count;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaSetDevice(int device)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaSetDevice;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & device, sizeof device);
  chars_sent += sizeof device;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaMemcpyAsync(void * dst, const void * src, size_t count,
                  cudaMemcpyKind kind, cudaStream_t stream)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemcpyAsync;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & count, sizeof count);
  chars_sent += sizeof count;
  memcpy(send_buf + chars_sent, & kind, sizeof kind);
  chars_sent += sizeof kind;
  memcpy(send_buf + chars_sent, & stream, sizeof stream);
  chars_sent += sizeof stream;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  enum cudaMemcpyKind direction;
  if (kind == cudaMemcpyDefault) {
    cudaMemcpyGetDirection(dst, src, &direction);
  }
  int size = -1;
  size = count;
  direction = kind;
  if (direction == cudaMemcpyHostToDevice ||
      direction == cudaMemcpyHostToHost) {
    // Send source buffer to proxy process
    // NOTE: As an optimization, HostToHost could be done locally.
    // NOTE:  This assumes no pinnned memory.
    JASSERT(write(skt_master, src, size) == size) (JASSERT_ERRNO);
  }
  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);
  size = count;
  direction = kind;
  if (direction == cudaMemcpyDeviceToHost ||
      direction == cudaMemcpyHostToHost) {
    // Receive dest buffer from proxy process
    // NOTE:  This assumes no pinnned memory.
    JASSERT(read(skt_master, dst, size) == size) (JASSERT_ERRNO);
  }

  return ret_val;
}

EXTERNC cudaError_t
cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemsetAsync;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & devPtr, sizeof devPtr);
  chars_sent += sizeof devPtr;
  memcpy(send_buf + chars_sent, & value, sizeof value);
  chars_sent += sizeof value;
  memcpy(send_buf + chars_sent, & count, sizeof count);
  chars_sent += sizeof count;
  memcpy(send_buf + chars_sent, & stream, sizeof stream);
  chars_sent += sizeof stream;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks,
      const void * func, int blockSize, size_t dynamicSMemSize)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaOccupancyMaxActiveBlocksPerMultiprocessor;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & func, sizeof func);
  chars_sent += sizeof func;
  memcpy(send_buf + chars_sent, & blockSize, sizeof blockSize);
  chars_sent += sizeof blockSize;
  memcpy(send_buf + chars_sent, & dynamicSMemSize, sizeof dynamicSMemSize);
  chars_sent += sizeof dynamicSMemSize;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *numBlocks;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(numBlocks, recv_buf + chars_rcvd, sizeof *numBlocks);
  chars_rcvd += sizeof *numBlocks;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaChannelFormatDesc
cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f)
{
  if (!initialized)
    proxy_initialize();

  cudaChannelFormatDesc ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaCreateChannelDesc;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & x, sizeof x);
  chars_sent += sizeof x;
  memcpy(send_buf + chars_sent, & y, sizeof y);
  chars_sent += sizeof y;
  memcpy(send_buf + chars_sent, & z, sizeof z);
  chars_sent += sizeof z;
  memcpy(send_buf + chars_sent, & w, sizeof w);
  chars_sent += sizeof w;
  memcpy(send_buf + chars_sent, & f, sizeof f);
  chars_sent += sizeof f;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  log_append(send_buf, chars_sent);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaFuncSetCacheConfig;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & func, sizeof func);
  chars_sent += sizeof func;
  memcpy(send_buf + chars_sent, & cacheConfig, sizeof cacheConfig);
  chars_sent += sizeof cacheConfig;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC const char *
cudaGetErrorString(cudaError_t error)
{
  if (!initialized)
    proxy_initialize();

  const char * ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaGetErrorString;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & error, sizeof error);
  chars_sent += sizeof error;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaMemGetInfo(size_t * free, size_t * total)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemGetInfo;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *free + sizeof *total;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(free, recv_buf + chars_rcvd, sizeof *free);
  chars_rcvd += sizeof *free;
  memcpy(total, recv_buf + chars_rcvd, sizeof *total);
  chars_rcvd += sizeof *total;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset,
          const void * src, size_t count, enum cudaMemcpyKind kind)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaMemcpyToArray;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);
  memcpy(send_buf + chars_sent, & wOffset, sizeof wOffset);
  chars_sent += sizeof wOffset;
  memcpy(send_buf + chars_sent, & hOffset, sizeof hOffset);
  chars_sent += sizeof hOffset;
  memcpy(send_buf + chars_sent, & count, sizeof count);
  chars_sent += sizeof count;
  memcpy(send_buf + chars_sent, & kind, sizeof kind);
  chars_sent += sizeof kind;

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  enum cudaMemcpyKind direction;
  if (kind == cudaMemcpyDefault) {
    cudaMemcpyGetDirection(dst, src, &direction);
  }
  int size = -1;
  size = count;
  direction = kind;
  if (direction == cudaMemcpyHostToDevice ||
      direction == cudaMemcpyHostToHost) {
    // Send source buffer to proxy process
    // NOTE: As an optimization, HostToHost could be done locally.
    // NOTE:  This assumes no pinnned memory.
    JASSERT(write(skt_master, src, size) == size) (JASSERT_ERRNO);
  }
  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);
  size = count;
  direction = kind;
  if (direction == cudaMemcpyDeviceToHost ||
      direction == cudaMemcpyHostToHost) {
    // Receive dest buffer from proxy process
    // NOTE:  This assumes no pinnned memory.
    JASSERT(read(skt_master, dst, size) == size) (JASSERT_ERRNO);
  }

  return ret_val;
}

EXTERNC cudaError_t
cudaStreamCreate(cudaStream_t * pStream)
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaStreamCreate;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);
  log_append(send_buf, chars_sent);

  // Receive the OUT arguments after the proxy made the function call
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof *pStream;
  chars_rcvd += sizeof ret_val;
  JASSERT(read(skt_master, recv_buf, chars_rcvd) == chars_rcvd)
         (JASSERT_ERRNO);

  // Extract OUT variables
  chars_rcvd = 0;
  memcpy(pStream, recv_buf + chars_rcvd, sizeof *pStream);
  chars_rcvd += sizeof *pStream;

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

EXTERNC cudaError_t
cudaThreadExit()
{
  if (!initialized)
    proxy_initialize();

  cudaError_t ret_val;
  char send_buf[1000];
  char recv_buf[1000];
  int chars_sent = 0;
  int chars_rcvd = 0;

  // Write the IN arguments to the proxy
  enum cuda_op op = OP_cudaThreadExit;
  memcpy(send_buf + chars_sent, &op, sizeof op);
  chars_sent += sizeof(enum cuda_op);

  // Send op code and args to proxy
  JASSERT(write(skt_master, send_buf, chars_sent) == chars_sent)
         (JASSERT_ERRNO);

  // Receive the OUT arguments after the proxy made the function call
  // No primitive arguments to receive.  Will not read args from skt_master.

  memcpy(&ret_val, recv_buf + chars_rcvd, sizeof ret_val);

  return ret_val;
}

// Verbatim from main.template
EXTERNC enum cudaMemcpyKind
cudaMemcpyGetDirection ( const void * destPtr , const void * srcPtr,
                                    enum cudaMemcpyKind * direction )
{cudaPointerAttributes destPtrAttr;
cudaPointerAttributes srcPtrAttr;
JASSERT(cudaPointerGetAttributes(&destPtrAttr, destPtr) == cudaSuccess).
                           Text ( "Error getting pointer properties" );
JASSERT (cudaPointerGetAttributes(&srcPtrAttr, srcPtr) == cudaSuccess).
                           Text ( "Error getting pointer properties" );
if (destPtrAttr.memoryType == cudaMemoryTypeHost &&
                 srcPtrAttr.memoryType == cudaMemoryTypeHost )
{* direction = cudaMemcpyHostToHost;
} else if (destPtrAttr.memoryType == cudaMemoryTypeHost &&
srcPtrAttr . memoryType == cudaMemoryTypeDevice)
{* direction = cudaMemcpyDeviceToHost;
} else if ( destPtrAttr . memoryType == cudaMemoryTypeDevice &&
srcPtrAttr . memoryType == cudaMemoryTypeHost )
{* direction = cudaMemcpyHostToDevice;
} else if ( destPtrAttr . memoryType == cudaMemoryTypeDevice &&
srcPtrAttr . memoryType == cudaMemoryTypeDevice )
{* direction = cudaMemcpyDeviceToDevice;
} else
{JASSERT ( false ) . Text ( "DMTCP/CUDA internal error" );
}}

// Verbatim from main.template
EXTERNC cudaError_t cudaMallocHost ( void * * ptr , size_t size )
{* ptr = malloc ( size );
return cudaSuccess;
};
