#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <assert.h>
#include <dlfcn.h>
#include <cuda_profiler_api.h>

#ifdef USE_SHM
# include <sys/ipc.h>
# include <sys/shm.h>
#endif

// Definitions of common structs shared with the main process
#include "cuda_plugin.h"
#include "trampolines.h"

#define SKTNAME "proxy"
#define specialCudaReturnValue  60000

#ifndef EXTERNC
# ifdef __cplusplus
#  define EXTERNC extern "C"
# else // ifdef __cplusplus
#  define EXTERNC
# endif // ifdef __cplusplus
#endif // ifndef EXTERNC

int skt_accept;

#ifdef USE_SHM
int shmID;
void *shmaddr;
#endif

static trampoline_info_t main_trampoline_info;

static int start_proxy(void);

static void do_work();

// This is the trampoline destination for the user main; this does not return
// to the user main function.
int main_wrapper();

__attribute__((constructor))
void proxy_init()
{
  void *handle = dlopen(NULL, RTLD_NOW);
  void *addr = dlsym(handle, "main");
  assert(addr != NULL);
  dmtcp_setup_trampoline_by_addr(addr, (void*)&main_wrapper, &main_trampoline_info);
}

static int start_proxy(void)
{
  // set up the server
  int skt_proxy;
  struct sockaddr_un sa_proxy;
  const char *sktname = getenv("CUDA_PROXY_SOCKET");
  if (!sktname) {
    sktname = SKTNAME;
  }

  (void) unlink(sktname);
  memset(&sa_proxy, 0, sizeof(sa_proxy));
  strcpy(sa_proxy.sun_path, sktname);
  sa_proxy.sun_family = AF_UNIX;

  if ((skt_proxy = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
  {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  if (bind(skt_proxy, (struct sockaddr *)&sa_proxy, sizeof(sa_proxy)) == -1)
  {
    perror("bind()");
    exit(EXIT_FAILURE);
  }

  if (listen(skt_proxy, SOMAXCONN) == -1)
  {
    perror("listen()");
    exit(EXIT_FAILURE);
  }
 
  if ((skt_accept = accept(skt_proxy, NULL, 0)) == -1)
  {
    perror("accept()");
    exit(EXIT_FAILURE);
  }

#ifdef USE_SHM
  // read the shmID
  if (read(skt_accept, &shmID, sizeof(shmID)) == -1)
  {
    perror("read()");
    exit(EXIT_FAILURE);
  }


  if ((shmaddr = shmat(shmID, NULL, 0)) == (void *) -1)
  {
    perror("shmat()");
    exit(EXIT_FAILURE);
  }
#endif

  // do_work() has an infinite 'while(1)' loop.
  // do_work(); // never returns
}


// Generated by cuda-wrappers.py and main.template

int main_wrapper() {
  // FIXME: ADD: do_init()
  start_proxy();
  do_work();
  return 0;
}

void do_work() {
  while(1) {
    enum cuda_op op;

    assert(read(skt_accept, &op, sizeof op) == sizeof op);
    switch (op) {
    case OP_cudaMalloc:
      FNC_cudaMalloc();
      break;
    case OP_cudaFree:
      FNC_cudaFree();
      break;
    case OP_cudaPointerGetAttributes:
      FNC_cudaPointerGetAttributes();
      break;
    case OP_cudaMemcpy:
      FNC_cudaMemcpy();
      break;
    case OP_cudaMemcpy2D:
      FNC_cudaMemcpy2D();
      break;
    case OP_cudaMallocArray:
      FNC_cudaMallocArray();
      break;
    case OP_cudaFreeArray:
      FNC_cudaFreeArray();
      break;
    case OP_cudaConfigureCall:
      FNC_cudaConfigureCall();
      break;
    case OP_cudaSetupArgument:
      FNC_cudaSetupArgument();
      break;
    case OP_cudaThreadSynchronize:
      FNC_cudaThreadSynchronize();
      break;
    case OP_cudaGetLastError:
      FNC_cudaGetLastError();
      break;
    case OP_cudaMallocPitch:
      FNC_cudaMallocPitch();
      break;
    case OP_cudaDeviceReset:
      FNC_cudaDeviceReset();
      break;
    case OP_cudaCreateTextureObject:
      FNC_cudaCreateTextureObject();
      break;
    case OP_cudaPeekAtLastError:
      FNC_cudaPeekAtLastError();
      break;
    case OP_cudaProfilerStart:
      FNC_cudaProfilerStart();
      break;
    case OP_cudaProfilerStop:
      FNC_cudaProfilerStop();
      break;
    case OP_cudaStreamSynchronize:
      FNC_cudaStreamSynchronize();
      break;
    case OP_cudaUnbindTexture:
      FNC_cudaUnbindTexture();
      break;
    case OP_cudaDestroyTextureObject:
      FNC_cudaDestroyTextureObject();
      break;
    case OP_cudaEventQuery:
      FNC_cudaEventQuery();
      break;
    case OP_cudaDeviceCanAccessPeer:
      FNC_cudaDeviceCanAccessPeer();
      break;
    case OP_cudaDeviceGetAttribute:
      FNC_cudaDeviceGetAttribute();
      break;
    case OP_cudaDeviceSetCacheConfig:
      FNC_cudaDeviceSetCacheConfig();
      break;
    case OP_cudaDeviceSetSharedMemConfig:
      FNC_cudaDeviceSetSharedMemConfig();
      break;
    case OP_cudaDeviceSynchronize:
      FNC_cudaDeviceSynchronize();
      break;
    case OP_cudaEventCreateWithFlags:
      FNC_cudaEventCreateWithFlags();
      break;
    case OP_cudaEventCreate:
      FNC_cudaEventCreate();
      break;
    case OP_cudaEventDestroy:
      FNC_cudaEventDestroy();
      break;
    case OP_cudaEventSynchronize:
      FNC_cudaEventSynchronize();
      break;
    case OP_cudaEventElapsedTime:
      FNC_cudaEventElapsedTime();
      break;
    case OP_cudaEventRecord:
      FNC_cudaEventRecord();
      break;
    case OP_cudaFuncGetAttributes:
      FNC_cudaFuncGetAttributes();
      break;
    case OP_cudaGetDevice:
      FNC_cudaGetDevice();
      break;
    case OP_cudaGetDeviceCount:
      FNC_cudaGetDeviceCount();
      break;
    case OP_cudaGetDeviceProperties:
      FNC_cudaGetDeviceProperties();
      break;
    case OP_cudaMemset:
      FNC_cudaMemset();
      break;
    case OP_cudaSetDevice:
      FNC_cudaSetDevice();
      break;
    case OP_cudaMemcpyAsync:
      FNC_cudaMemcpyAsync();
      break;
    case OP_cudaMemsetAsync:
      FNC_cudaMemsetAsync();
      break;
    case OP_cudaOccupancyMaxActiveBlocksPerMultiprocessor:
      FNC_cudaOccupancyMaxActiveBlocksPerMultiprocessor();
      break;
    case OP_cudaCreateChannelDesc:
      FNC_cudaCreateChannelDesc();
      break;
    case OP_cudaFuncSetCacheConfig:
      FNC_cudaFuncSetCacheConfig();
      break;
    case OP_cudaGetErrorString:
      FNC_cudaGetErrorString();
      break;
    case OP_cudaMemGetInfo:
      FNC_cudaMemGetInfo();
      break;
    case OP_cudaMemcpyToArray:
      FNC_cudaMemcpyToArray();
      break;
    case OP_cudaStreamCreate:
      FNC_cudaStreamCreate();
      break;
    case OP_cudaThreadExit:
      FNC_cudaThreadExit();
      break;
    }
  }
}


void FNC_cudaMalloc(void) {
  void * * pointer;
  size_t size;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;
  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof size;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&size, recv_buf + chars_rcvd, sizeof size);
  chars_rcvd += sizeof size;

  // Declare base variables for OUT arguments to point to
  void * base_pointer;
  pointer = &base_pointer;

  // Make the function call
  cudaError_t ret_val = cudaMalloc(pointer, size);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, pointer, sizeof *pointer);
  chars_sent += sizeof *pointer;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  chars_sent += sizeof ret_val;
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaPointerGetAttributes(void) {
  cudaPointerAttributes * attributes;
  void * ptr;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof ptr;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&ptr, recv_buf + chars_rcvd, sizeof ptr);
  chars_rcvd += sizeof ptr;

  // Declare base variables for OUT arguments to point to
  cudaPointerAttributes base_attributes;
  attributes = &base_attributes;

  // Make the function call
  cudaError_t ret_val = cudaPointerGetAttributes(attributes, ptr);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, attributes, sizeof *attributes);
  chars_sent += sizeof *attributes;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaMemcpy(void) {
  void * dst;
  void * src;
  size_t count;
  enum cudaMemcpyKind direction;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof count + sizeof direction + sizeof dst + sizeof src;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&count, recv_buf + chars_rcvd, sizeof count);
  chars_rcvd += sizeof count;
  memcpy(&direction, recv_buf + chars_rcvd, sizeof direction);
  chars_rcvd += sizeof direction;
  memcpy(&dst, recv_buf + chars_rcvd, sizeof dst);
  chars_rcvd += sizeof dst;
  memcpy(&src, recv_buf + chars_rcvd, sizeof src);
  chars_rcvd += sizeof src;

  int size = -1;
  size = count;
  if (direction == cudaMemcpyHostToDevice) {
    // Receive source buffer from application process
    src = malloc(size); // src is implicitly modified.
    assert(read(skt_accept, src, size) == size);
    // NOTE:  This assumes no pinnned memory.
  }
  else if (direction == cudaMemcpyDeviceToHost) {
    dst = malloc(size); // dst is implicitly modified.
  }
  // NOTE: HostToHost is handled in the application process.
  //       DeviceToDevice: both dst and src are addr on
  //       the device.
  // Make the function call
  cudaError_t ret_val = cudaMemcpy(dst, src, count, direction);

  // NOTE: src and dst should be freed
  if (direction == cudaMemcpyHostToDevice) {
    free(src);
  }
  else if (direction == cudaMemcpyDeviceToHost) {
    // send source buffer to the application process
    assert(write(skt_accept, dst, size) == size);
    free(dst);
  }
  // Write back ret_val to the application.
  chars_sent = sizeof ret_val;
  assert(write(skt_accept, &ret_val, chars_sent) == chars_sent);
};

void FNC_cudaMemcpy2D(void) {
  void * dst;
  size_t dpitch;
  void * src;
  size_t spitch;
  size_t width;
  size_t height;
  enum cudaMemcpyKind kind;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof dpitch + sizeof spitch + sizeof width + sizeof height + sizeof kind;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&dpitch, recv_buf + chars_rcvd, sizeof dpitch);
  chars_rcvd += sizeof dpitch;
  memcpy(&spitch, recv_buf + chars_rcvd, sizeof spitch);
  chars_rcvd += sizeof spitch;
  memcpy(&width, recv_buf + chars_rcvd, sizeof width);
  chars_rcvd += sizeof width;
  memcpy(&height, recv_buf + chars_rcvd, sizeof height);
  chars_rcvd += sizeof height;
  memcpy(&kind, recv_buf + chars_rcvd, sizeof kind);
  chars_rcvd += sizeof kind;
  enum cudaMemcpyKind direction;
  int size = -1;
  size = spitch * height;
  direction = kind;
  if (direction == cudaMemcpyHostToDevice ||
      direction == cudaMemcpyHostToHost) {
    // Receive source buffer from application process
    src = malloc(size);
    assert(read(skt_accept, src, size) == size);
    // Get ready for receiving memory from device when making CUDA call
    size = dpitch * height;
    // NEEDED FOR DeviceToHost; SHOULD REUSE OLD malloc() for HostToHost
    // NOTE:  This assumes no pinnned memory.
    dst = malloc(size);
  }

  // Make the function call
  cudaError_t ret_val = cudaMemcpy2D(dst, dpitch, src, spitch, width, height, kind);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
  direction = kind;
  if (direction == cudaMemcpyDeviceToHost ||
      direction == cudaMemcpyHostToHost) {
    // Send  dest buffer to application process
    // NOTE:  This assumes no pinnned memory.
    free(src);
    assert(write(skt_accept, dst, size) == size);
    free(dst);
  }
};

void FNC_cudaMallocArray(void) {
  struct cudaArray * * array;
  struct cudaChannelFormatDesc * desc;
  size_t width;
  size_t height;
  unsigned int flags;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof width + sizeof height + sizeof flags + sizeof *desc;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  // Declare base variables for OUT arguments to point to
  struct cudaChannelFormatDesc base_desc;
  desc = &base_desc;
  memcpy(&base_desc, recv_buf + chars_rcvd, sizeof *array);
  chars_rcvd += sizeof *array;
  memcpy(&width, recv_buf + chars_rcvd, sizeof width);
  chars_rcvd += sizeof width;
  memcpy(&height, recv_buf + chars_rcvd, sizeof height);
  chars_rcvd += sizeof height;
  memcpy(&flags, recv_buf + chars_rcvd, sizeof flags);
  chars_rcvd += sizeof flags;

  // Declare base variables for OUT arguments to point to
  struct cudaArray * base_array;
  array = &base_array;

  // Make the function call
  cudaError_t ret_val = cudaMallocArray(array, desc, width, height, flags);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, array, sizeof *array);
  chars_sent += sizeof *array;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaFreeArray(void) {
  struct cudaArray * array;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof array;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&array, recv_buf + chars_rcvd, sizeof array);
  chars_rcvd += sizeof array;

  // Make the function call
  cudaError_t ret_val = cudaFreeArray(array);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaConfigureCall(void) {
  dim3 gridDim;
  dim3 blockDim;
  size_t sharedMem;
  cudaStream_t stream;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof gridDim + sizeof blockDim + sizeof sharedMem + sizeof stream;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&gridDim, recv_buf + chars_rcvd, sizeof gridDim);
  chars_rcvd += sizeof gridDim;
  memcpy(&blockDim, recv_buf + chars_rcvd, sizeof blockDim);
  chars_rcvd += sizeof blockDim;
  memcpy(&sharedMem, recv_buf + chars_rcvd, sizeof sharedMem);
  chars_rcvd += sizeof sharedMem;
  memcpy(&stream, recv_buf + chars_rcvd, sizeof stream);
  chars_rcvd += sizeof stream;

  // Make the function call
  cudaError_t ret_val = cudaConfigureCall(gridDim, blockDim, sharedMem, stream);

  // Write back the arguments to the application
  chars_sent = sizeof ret_val;
  assert(write(skt_accept, &ret_val, chars_sent) == chars_sent);
};

void FNC_cudaSetupArgument(void) {
  void * arg;
  size_t size;
  size_t offset;

  char recv_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof size + sizeof offset;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&size, recv_buf + chars_rcvd, sizeof size);
  chars_rcvd += sizeof size;
  memcpy(&offset, recv_buf + chars_rcvd, sizeof offset);
  chars_rcvd += sizeof offset;
  assert(read(skt_accept, recv_buf + chars_rcvd, size) == size);
  arg = recv_buf + chars_rcvd;
  chars_rcvd += size;

  // Make the function call
  cudaError_t ret_val = cudaSetupArgument(arg, size, offset);

  // Write back the arguments to the application
  chars_sent = sizeof ret_val;
  assert(write(skt_accept, &ret_val, chars_sent) == chars_sent);
};

void FNC_cudaLaunch(void) {
  void * func;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof func;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&func, recv_buf + chars_rcvd, sizeof func);
  chars_rcvd += sizeof func;

  // Make the function call
  cudaError_t ret_val = cudaLaunch(func);

  // Write back the arguments to the application
  chars_sent = sizeof ret_val;
  assert(write(skt_accept, &ret_val, chars_sent) == chars_sent);
};

void FNC_cudaThreadSynchronize(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaThreadSynchronize();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaGetLastError(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaGetLastError();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaMallocPitch(void) {
  void * * devPtr;
  size_t * pitch;
  size_t width;
  size_t height;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof width + sizeof height;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&width, recv_buf + chars_rcvd, sizeof width);
  chars_rcvd += sizeof width;
  memcpy(&height, recv_buf + chars_rcvd, sizeof height);
  chars_rcvd += sizeof height;

  // Declare base variables for OUT arguments to point to
  void * base_devPtr;
  devPtr = &base_devPtr;
  size_t base_pitch;
  pitch = &base_pitch;

  // Make the function call
  cudaError_t ret_val = cudaMallocPitch(devPtr, pitch, width, height);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, devPtr, sizeof *devPtr);
  chars_sent += sizeof *devPtr;
  memcpy(send_buf + chars_sent, pitch, sizeof *pitch);
  chars_sent += sizeof *pitch;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDeviceReset(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaDeviceReset();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaCreateTextureObject(void) {
  cudaTextureObject_t * pTexObject;
  struct cudaResourceDesc * pResDesc;
  struct cudaTextureDesc * pTexDesc;
  struct cudaResourceViewDesc * pResViewDesc;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof pResDesc + sizeof pTexDesc + sizeof pResViewDesc;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&pResDesc, recv_buf + chars_rcvd, sizeof pResDesc);
  chars_rcvd += sizeof pResDesc;
  memcpy(&pTexDesc, recv_buf + chars_rcvd, sizeof pTexDesc);
  chars_rcvd += sizeof pTexDesc;
  memcpy(&pResViewDesc, recv_buf + chars_rcvd, sizeof pResViewDesc);
  chars_rcvd += sizeof pResViewDesc;

  // Declare base variables for OUT arguments to point to
  cudaTextureObject_t base_pTexObject;
  pTexObject = &base_pTexObject;

  // Make the function call
  cudaError_t ret_val = cudaCreateTextureObject(pTexObject, pResDesc, pTexDesc, pResViewDesc);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, pTexObject, sizeof *pTexObject);
  chars_sent += sizeof *pTexObject;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaPeekAtLastError(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaPeekAtLastError();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaProfilerStart(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaProfilerStart();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaProfilerStop(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaProfilerStop();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaStreamSynchronize(void) {
  cudaStream_t stream;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof stream;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&stream, recv_buf + chars_rcvd, sizeof stream);
  chars_rcvd += sizeof stream;

  // Make the function call
  cudaError_t ret_val = cudaStreamSynchronize(stream);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaUnbindTexture(void) {
  textureReference * texref;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof texref;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&texref, recv_buf + chars_rcvd, sizeof texref);
  chars_rcvd += sizeof texref;

  // Make the function call
  cudaError_t ret_val = cudaUnbindTexture(texref);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDestroyTextureObject(void) {
  cudaTextureObject_t texObject;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof texObject;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&texObject, recv_buf + chars_rcvd, sizeof texObject);
  chars_rcvd += sizeof texObject;

  // Make the function call
  cudaError_t ret_val = cudaDestroyTextureObject(texObject);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventQuery(void) {
  cudaEvent_t event;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof event;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&event, recv_buf + chars_rcvd, sizeof event);
  chars_rcvd += sizeof event;

  // Make the function call
  cudaError_t ret_val = cudaEventQuery(event);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDeviceCanAccessPeer(void) {
  int * canAccessPeer;
  int device;
  int peerDevice;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof device + sizeof peerDevice;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&device, recv_buf + chars_rcvd, sizeof device);
  chars_rcvd += sizeof device;
  memcpy(&peerDevice, recv_buf + chars_rcvd, sizeof peerDevice);
  chars_rcvd += sizeof peerDevice;

  // Declare base variables for OUT arguments to point to
  int base_canAccessPeer;
  canAccessPeer = &base_canAccessPeer;

  // Make the function call
  cudaError_t ret_val = cudaDeviceCanAccessPeer(canAccessPeer, device, peerDevice);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, canAccessPeer, sizeof *canAccessPeer);
  chars_sent += sizeof *canAccessPeer;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDeviceGetAttribute(void) {
  int * value;
  cudaDeviceAttr attr;
  int device;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof attr + sizeof device;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&attr, recv_buf + chars_rcvd, sizeof attr);
  chars_rcvd += sizeof attr;
  memcpy(&device, recv_buf + chars_rcvd, sizeof device);
  chars_rcvd += sizeof device;

  // Declare base variables for OUT arguments to point to
  int base_value;
  value = &base_value;

  // Make the function call
  cudaError_t ret_val = cudaDeviceGetAttribute(value, attr, device);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, value, sizeof *value);
  chars_sent += sizeof *value;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDeviceSetCacheConfig(void) {
  cudaFuncCache cacheConfig;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof cacheConfig;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&cacheConfig, recv_buf + chars_rcvd, sizeof cacheConfig);
  chars_rcvd += sizeof cacheConfig;

  // Make the function call
  cudaError_t ret_val = cudaDeviceSetCacheConfig(cacheConfig);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDeviceSetSharedMemConfig(void) {
  cudaSharedMemConfig config;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof config;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&config, recv_buf + chars_rcvd, sizeof config);
  chars_rcvd += sizeof config;

  // Make the function call
  cudaError_t ret_val = cudaDeviceSetSharedMemConfig(config);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaDeviceSynchronize(void) {

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Make the function call
  cudaError_t ret_val = cudaDeviceSynchronize();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventCreateWithFlags(void) {
  cudaEvent_t * event;
  unsigned int flags;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof flags;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&flags, recv_buf + chars_rcvd, sizeof flags);
  chars_rcvd += sizeof flags;

  // Declare base variables for OUT arguments to point to
  cudaEvent_t base_event;
  event = &base_event;

  // Make the function call
  cudaError_t ret_val = cudaEventCreateWithFlags(event, flags);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, event, sizeof *event);
  chars_sent += sizeof *event;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventCreate(void) {
  cudaEvent_t * event;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Declare base variables for OUT arguments to point to
  cudaEvent_t base_event;
  event = &base_event;

  // Make the function call
  cudaError_t ret_val = cudaEventCreate(event);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, event, sizeof *event);
  chars_sent += sizeof *event;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventDestroy(void) {
  cudaEvent_t event;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof event;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&event, recv_buf + chars_rcvd, sizeof event);
  chars_rcvd += sizeof event;

  // Make the function call
  cudaError_t ret_val = cudaEventDestroy(event);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventSynchronize(void) {
  cudaEvent_t event;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof event;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&event, recv_buf + chars_rcvd, sizeof event);
  chars_rcvd += sizeof event;

  // Make the function call
  cudaError_t ret_val = cudaEventSynchronize(event);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventElapsedTime(void) {
  float * ms;
  cudaEvent_t start;
  cudaEvent_t end;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof start + sizeof end;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&start, recv_buf + chars_rcvd, sizeof start);
  chars_rcvd += sizeof start;
  memcpy(&end, recv_buf + chars_rcvd, sizeof end);
  chars_rcvd += sizeof end;

  // Declare base variables for OUT arguments to point to
  float base_ms;
  ms = &base_ms;

  // Make the function call
  cudaError_t ret_val = cudaEventElapsedTime(ms, start, end);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, ms, sizeof *ms);
  chars_sent += sizeof *ms;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaEventRecord(void) {
  cudaEvent_t event;
  cudaStream_t stream;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof event + sizeof stream;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&event, recv_buf + chars_rcvd, sizeof event);
  chars_rcvd += sizeof event;
  memcpy(&stream, recv_buf + chars_rcvd, sizeof stream);
  chars_rcvd += sizeof stream;

  // Make the function call
  cudaError_t ret_val = cudaEventRecord(event, stream);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaFuncGetAttributes(void) {
  cudaFuncAttributes * attr;
  void * func;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof func;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&func, recv_buf + chars_rcvd, sizeof func);
  chars_rcvd += sizeof func;

  // Declare base variables for OUT arguments to point to
  cudaFuncAttributes base_attr;
  attr = &base_attr;

  // Make the function call
  cudaError_t ret_val = cudaFuncGetAttributes(attr, func);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, attr, sizeof *attr);
  chars_sent += sizeof *attr;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaGetDevice(void) {
  int * device;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Declare base variables for OUT arguments to point to
  int base_device;
  device = &base_device;

  // Make the function call
  cudaError_t ret_val = cudaGetDevice(device);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, device, sizeof *device);
  chars_sent += sizeof *device;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaGetDeviceCount(void) {
  int * count;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Declare base variables for OUT arguments to point to
  int base_count;
  count = &base_count;

  // Make the function call
  cudaError_t ret_val = cudaGetDeviceCount(count);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, count, sizeof *count);
  chars_sent += sizeof *count;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaGetDeviceProperties(void) {
  cudaDeviceProp * prop;
  int device;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof device + sizeof *prop;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  // Declare base variables for OUT arguments to point to
  cudaDeviceProp base_prop;
  prop = &base_prop;
  memcpy(&base_prop, recv_buf + chars_rcvd, sizeof *prop);
  chars_rcvd += sizeof *prop;
  memcpy(&device, recv_buf + chars_rcvd, sizeof device);
  chars_rcvd += sizeof device;

  // Declare base variables for OUT arguments to point to
  prop = &base_prop;

  // Make the function call
  cudaError_t ret_val = cudaGetDeviceProperties(prop, device);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, prop, sizeof *prop);
  chars_sent += sizeof *prop;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaMemset(void) {
  void * devPtr;
  int value;
  size_t count;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof devPtr + sizeof value + sizeof count;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&devPtr, recv_buf + chars_rcvd, sizeof devPtr);
  chars_rcvd += sizeof devPtr;
  memcpy(&value, recv_buf + chars_rcvd, sizeof value);
  chars_rcvd += sizeof value;
  memcpy(&count, recv_buf + chars_rcvd, sizeof count);
  chars_rcvd += sizeof count;

  // Make the function call
  cudaError_t ret_val = cudaMemset(devPtr, value, count);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaSetDevice(void) {
  int device;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof device;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&device, recv_buf + chars_rcvd, sizeof device);
  chars_rcvd += sizeof device;

  // Make the function call
  cudaError_t ret_val = cudaSetDevice(device);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaMemcpyAsync(void) {
  void * dst;
  void * src;
  size_t count;
  cudaMemcpyKind kind;
  cudaStream_t stream;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof count + sizeof kind + sizeof stream;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&count, recv_buf + chars_rcvd, sizeof count);
  chars_rcvd += sizeof count;
  memcpy(&kind, recv_buf + chars_rcvd, sizeof kind);
  chars_rcvd += sizeof kind;
  memcpy(&stream, recv_buf + chars_rcvd, sizeof stream);
  chars_rcvd += sizeof stream;
  enum cudaMemcpyKind direction;
  int size = -1;
  size = count;
  direction = kind;
  if (direction == cudaMemcpyHostToDevice ||
      direction == cudaMemcpyHostToHost) {
    // Receive source buffer from application process
    src = malloc(size);
    assert(read(skt_accept, src, size) == size);
    // Get ready for receiving memory from device when making CUDA call
    size = count;
    // NEEDED FOR DeviceToHost; SHOULD REUSE OLD malloc() for HostToHost
    // NOTE:  This assumes no pinnned memory.
    dst = malloc(size);
  }

  // Make the function call
  cudaError_t ret_val = cudaMemcpyAsync(dst, src, count, kind, stream);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
  direction = kind;
  if (direction == cudaMemcpyDeviceToHost ||
      direction == cudaMemcpyHostToHost) {
    // Send  dest buffer to application process
    // NOTE:  This assumes no pinnned memory.
    free(src);
    assert(write(skt_accept, dst, size) == size);
    free(dst);
  }
};

void FNC_cudaMemsetAsync(void) {
  void * devPtr;
  int value;
  size_t count;
  cudaStream_t stream;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof devPtr + sizeof value + sizeof count + sizeof stream;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&devPtr, recv_buf + chars_rcvd, sizeof devPtr);
  chars_rcvd += sizeof devPtr;
  memcpy(&value, recv_buf + chars_rcvd, sizeof value);
  chars_rcvd += sizeof value;
  memcpy(&count, recv_buf + chars_rcvd, sizeof count);
  chars_rcvd += sizeof count;
  memcpy(&stream, recv_buf + chars_rcvd, sizeof stream);
  chars_rcvd += sizeof stream;

  // Make the function call
  cudaError_t ret_val = cudaMemsetAsync(devPtr, value, count, stream);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaOccupancyMaxActiveBlocksPerMultiprocessor(void) {
  int * numBlocks;
  void * func;
  int blockSize;
  size_t dynamicSMemSize;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof func + sizeof blockSize + sizeof dynamicSMemSize;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&func, recv_buf + chars_rcvd, sizeof func);
  chars_rcvd += sizeof func;
  memcpy(&blockSize, recv_buf + chars_rcvd, sizeof blockSize);
  chars_rcvd += sizeof blockSize;
  memcpy(&dynamicSMemSize, recv_buf + chars_rcvd, sizeof dynamicSMemSize);
  chars_rcvd += sizeof dynamicSMemSize;

  // Declare base variables for OUT arguments to point to
  int base_numBlocks;
  numBlocks = &base_numBlocks;

  // Make the function call
  cudaError_t ret_val = cudaOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks, func, blockSize, dynamicSMemSize);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, numBlocks, sizeof *numBlocks);
  chars_sent += sizeof *numBlocks;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaCreateChannelDesc(void) {
  int x;
  int y;
  int z;
  int w;
  cudaChannelFormatKind f;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof x + sizeof y + sizeof z + sizeof w + sizeof f;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&x, recv_buf + chars_rcvd, sizeof x);
  chars_rcvd += sizeof x;
  memcpy(&y, recv_buf + chars_rcvd, sizeof y);
  chars_rcvd += sizeof y;
  memcpy(&z, recv_buf + chars_rcvd, sizeof z);
  chars_rcvd += sizeof z;
  memcpy(&w, recv_buf + chars_rcvd, sizeof w);
  chars_rcvd += sizeof w;
  memcpy(&f, recv_buf + chars_rcvd, sizeof f);
  chars_rcvd += sizeof f;

  // Make the function call
  cudaChannelFormatDesc ret_val = cudaCreateChannelDesc(x, y, z, w, f);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaFuncSetCacheConfig(void) {
  void * func;
  cudaFuncCache cacheConfig;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof func + sizeof cacheConfig;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&func, recv_buf + chars_rcvd, sizeof func);
  chars_rcvd += sizeof func;
  memcpy(&cacheConfig, recv_buf + chars_rcvd, sizeof cacheConfig);
  chars_rcvd += sizeof cacheConfig;

  // Make the function call
  cudaError_t ret_val = cudaFuncSetCacheConfig(func, cacheConfig);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaGetErrorString(void) {
  cudaError_t error;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof error;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&error, recv_buf + chars_rcvd, sizeof error);
  chars_rcvd += sizeof error;

  // Make the function call
  const char * ret_val = cudaGetErrorString(error);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaMemGetInfo(void) {
  size_t * free;
  size_t * total;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Declare base variables for OUT arguments to point to
  size_t base_free;
  free = &base_free;
  size_t base_total;
  total = &base_total;

  // Make the function call
  cudaError_t ret_val = cudaMemGetInfo(free, total);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, free, sizeof *free);
  chars_sent += sizeof *free;
  memcpy(send_buf + chars_sent, total, sizeof *total);
  chars_sent += sizeof *total;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaMemcpyToArray(void) {
  cudaArray_t dst;
  size_t wOffset;
  size_t hOffset;
  void * src;
  size_t count;
  enum cudaMemcpyKind kind;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof wOffset + sizeof hOffset + sizeof count + sizeof kind;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&wOffset, recv_buf + chars_rcvd, sizeof wOffset);
  chars_rcvd += sizeof wOffset;
  memcpy(&hOffset, recv_buf + chars_rcvd, sizeof hOffset);
  chars_rcvd += sizeof hOffset;
  memcpy(&count, recv_buf + chars_rcvd, sizeof count);
  chars_rcvd += sizeof count;
  memcpy(&kind, recv_buf + chars_rcvd, sizeof kind);
  chars_rcvd += sizeof kind;
  enum cudaMemcpyKind direction;
  int size = -1;
  size = count;
  direction = kind;
  if (direction == cudaMemcpyHostToDevice ||
      direction == cudaMemcpyHostToHost) {
    // Receive source buffer from application process
    src = malloc(size);
    assert(read(skt_accept, src, size) == size);
    // Get ready for receiving memory from device when making CUDA call
    size = count;
    // NEEDED FOR DeviceToHost; SHOULD REUSE OLD malloc() for HostToHost
    // NOTE:  This assumes no pinnned memory.
    dst = (cudaArray_t) malloc(size);
  }

  // Make the function call
  cudaError_t ret_val = cudaMemcpyToArray(dst, wOffset, hOffset, src, count, kind);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
  direction = kind;
  if (direction == cudaMemcpyDeviceToHost ||
      direction == cudaMemcpyHostToHost) {
    // Send  dest buffer to application process
    // NOTE:  This assumes no pinnned memory.
    free(src);
    assert(write(skt_accept, dst, size) == size);
    free(dst);
  }
};

void FNC_cudaStreamCreate(void) {
  cudaStream_t * pStream;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.
  chars_rcvd = 0;

  // Declare base variables for OUT arguments to point to
  cudaStream_t base_pStream;
  pStream = &base_pStream;

  // Make the function call
  cudaError_t ret_val = cudaStreamCreate(pStream);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, pStream, sizeof *pStream);
  chars_sent += sizeof *pStream;
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaThreadExit(void) {

  char send_buf[100];
  int chars_sent = 0;

  // Receive the arguments
  // No primitive args to receive.  Will not read from skt_accept.

  // Make the function call
  cudaError_t ret_val = cudaThreadExit();

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};

void FNC_cudaFree(void) {
  void * pointer;

  char recv_buf[100];
  char send_buf[100];
  int chars_rcvd = 0;
  int chars_sent = 0;

  // Receive the arguments
  // Compute total chars_rcvd to be read in the next msg
  chars_rcvd = sizeof pointer;
  assert(read(skt_accept, recv_buf, chars_rcvd) == chars_rcvd);
  chars_rcvd = 0;
  memcpy(&pointer, recv_buf + chars_rcvd, sizeof pointer);
  chars_rcvd += sizeof pointer;

  // Make the function call
  cudaError_t ret_val = cudaFree(pointer);

  // Write back the arguments to the application
  memcpy(send_buf + chars_sent, &ret_val, sizeof ret_val);
  assert(write(skt_accept, send_buf, chars_sent) == chars_sent);
};
